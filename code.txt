// =============================================
// package.json
// =============================================
{
  "name": "car-rental-backend",
  "version": "1.0.0",
  "description": "Car rental backend API with Node.js, Express, MongoDB",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest"
  },
  "dependencies": {
    "express": "^4.18.2",
    "mongoose": "^7.5.0",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "multer": "^1.4.5-lts.1",
    "cloudinary": "^1.40.0",
    "stripe": "^13.6.0",
    "nodemailer": "^6.9.4",
    "twilio": "^4.15.0",
    "winston": "^3.10.0",
    "morgan": "^1.10.0",
    "joi": "^17.9.2",
    "pdfkit": "^0.13.0",
    "openai": "^4.5.0",
    "express-rate-limit": "^6.10.0",
    "helmet": "^7.0.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.1",
    "jest": "^29.6.4"
  }
}

// =============================================
// .env (Environment Variables)
// =============================================
PORT=5000
NODE_ENV=development
MONGODB_URI=mongodb://localhost:27017/car-rental
JWT_SECRET=your_jwt_secret_key_here
JWT_EXPIRE=30d

# Stripe
STRIPE_SECRET_KEY=sk_test_your_stripe_secret_key
STRIPE_PUBLISHABLE_KEY=pk_test_your_stripe_publishable_key

# Cloudinary
CLOUDINARY_CLOUD_NAME=your_cloudinary_cloud_name
CLOUDINARY_API_KEY=your_cloudinary_api_key
CLOUDINARY_API_SECRET=your_cloudinary_api_secret

# Email (SendGrid/Nodemailer)
EMAIL_FROM=noreply@carrental.com
SENDGRID_API_KEY=your_sendgrid_api_key
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_USER=your_email@gmail.com
EMAIL_PASSWORD=your_app_password

# Twilio SMS
TWILIO_ACCOUNT_SID=your_twilio_account_sid
TWILIO_AUTH_TOKEN=your_twilio_auth_token
TWILIO_PHONE_NUMBER=your_twilio_phone_number

# OpenAI for Chatbot
OPENAI_API_KEY=your_openai_api_key

CLIENT_URL=http://localhost:3000

// =============================================
// .gitignore
// =============================================
node_modules/
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/
*.lcov

# nyc test coverage
.nyc_output

# Dependency directories
jspm_packages/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env.test

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# next.js build output
.next

# nuxt.js build output
.nuxt

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# MacOS
.DS_Store

# Windows
Thumbs.db

# IDEs
.vscode/
.idea/

# Uploads
uploads/

// =============================================
// server.js (Entry Point)
// =============================================
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const rateLimit = require('express-rate-limit');
const connectDB = require('./config/db');
const errorMiddleware = require('./middleware/errorMiddleware');
const logger = require('./utils/logger');

// Load env variables
require('dotenv').config();

// Connect to database
connectDB();

const app = express();

// Security middleware
app.use(helmet());

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});
app.use('/api', limiter);

// Body parser middleware
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: false }));

// CORS
app.use(cors({
  origin: process.env.CLIENT_URL || 'http://localhost:3000',
  credentials: true
}));

// Logging middleware
if (process.env.NODE_ENV === 'development') {
  app.use(morgan('dev'));
} else {
  app.use(morgan('combined', { stream: { write: message => logger.info(message) } }));
}

// Routes
app.use('/api/auth', require('./routes/authRoutes'));
app.use('/api/admin', require('./routes/adminRoutes'));
app.use('/api/cars', require('./routes/carRoutes'));
app.use('/api/bookings', require('./routes/bookingRoutes'));
app.use('/api/chatbot', require('./routes/chatbotRoutes'));
app.use('/api/coupons', require('./routes/couponRoutes'));

// Health check
app.get('/health', (req, res) => {
  res.status(200).json({ message: 'Server is running!' });
});

// Error handling middleware
app.use(errorMiddleware);

const PORT = process.env.PORT || 5000;

app.listen(PORT, () => {
  logger.info(`Server running in ${process.env.NODE_ENV} mode on port ${PORT}`);
});

// =============================================
// config/db.js
// =============================================
const mongoose = require('mongoose');
const logger = require('../utils/logger');

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGODB_URI);
    logger.info(`MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    logger.error(`Error: ${error.message}`);
    process.exit(1);
  }
};

module.exports = connectDB;

// =============================================
// config/stripe.js
// =============================================
const Stripe = require('stripe');
const stripe = Stripe(process.env.STRIPE_SECRET_KEY);

module.exports = stripe;

// =============================================
// config/cloudinary.js
// =============================================
const cloudinary = require('cloudinary').v2;

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET
});

module.exports = cloudinary;

// =============================================
// models/User.js
// =============================================
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Please add a name']
  },
  email: {
    type: String,
    required: [true, 'Please add an email'],
    unique: true,
    match: [/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/, 'Please add a valid email']
  },
  password: {
    type: String,
    required: [true, 'Please add a password'],
    minlength: 6,
    select: false
  },
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user'
  },
  phone: {
    type: String,
    required: [true, 'Please add a phone number']
  },
  address: {
    street: String,
    city: String,
    state: String,
    zipCode: String,
    country: String
  },
  isActive: {
    type: Boolean,
    default: true
  },
  lastLogin: Date,
  resetPasswordToken: String,
  resetPasswordExpire: Date
}, {
  timestamps: true
});

// Encrypt password using bcrypt
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) {
    next();
  }
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
});

// Match user entered password to hashed password in database
userSchema.methods.matchPassword = async function(enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

module.exports = mongoose.model('User', userSchema);

// =============================================
// models/Car.js
// =============================================
const mongoose = require('mongoose');

const carSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Please add car name']
  },
  brand: {
    type: String,
    required: [true, 'Please add car brand']
  },
  model: {
    type: String,
    required: [true, 'Please add car model']
  },
  year: {
    type: Number,
    required: [true, 'Please add manufacturing year']
  },
  rentPerHour: {
    type: Number,
    required: [true, 'Please add rent per hour']
  },
  fuelType: {
    type: String,
    enum: ['Petrol', 'Diesel', 'Electric', 'Hybrid'],
    required: [true, 'Please specify fuel type']
  },
  transmission: {
    type: String,
    enum: ['Manual', 'Automatic'],
    required: [true, 'Please specify transmission type']
  },
  seatingCapacity: {
    type: Number,
    required: [true, 'Please add seating capacity'],
    min: 2,
    max: 8
  },
  images: [{
    url: String,
    public_id: String
  }],
  features: [String],
  description: String,
  isAvailable: {
    type: Boolean,
    default: true
  },
  location: {
    city: String,
    state: String,
    country: String,
    coordinates: {
      lat: Number,
      lng: Number
    }
  },
  mileage: {
    type: Number,
    required: [true, 'Please add mileage']
  },
  registrationNumber: {
    type: String,
    required: [true, 'Please add registration number'],
    unique: true
  },
  insuranceDetails: {
    provider: String,
    policyNumber: String,
    expiryDate: Date
  },
  maintenanceSchedule: {
    lastService: Date,
    nextService: Date,
    serviceInterval: Number // in kilometers
  },
  rating: {
    average: {
      type: Number,
      default: 0
    },
    count: {
      type: Number,
      default: 0
    }
  }
}, {
  timestamps: true
});

// Index for search optimization
carSchema.index({ name: 'text', brand: 'text', model: 'text' });
carSchema.index({ 'location.city': 1 });
carSchema.index({ rentPerHour: 1 });
carSchema.index({ fuelType: 1 });

module.exports = mongoose.model('Car', carSchema);

// =============================================
// models/Booking.js
// =============================================
const mongoose = require('mongoose');

const bookingSchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.ObjectId,
    ref: 'User',
    required: true
  },
  car: {
    type: mongoose.Schema.ObjectId,
    ref: 'Car',
    required: true
  },
  startDate: {
    type: Date,
    required: [true, 'Please provide start date']
  },
  endDate: {
    type: Date,
    required: [true, 'Please provide end date']
  },
  pickupLocation: {
    address: String,
    city: String,
    state: String,
    coordinates: {
      lat: Number,
      lng: Number
    }
  },
  dropoffLocation: {
    address: String,
    city: String,
    state: String,
    coordinates: {
      lat: Number,
      lng: Number
    }
  },
  totalHours: {
    type: Number,
    required: true
  },
  totalAmount: {
    type: Number,
    required: true
  },
  paymentDetails: {
    stripeSessionId: String,
    stripePaymentIntentId: String,
    transactionId: String,
    paymentStatus: {
      type: String,
      enum: ['pending', 'completed', 'failed', 'refunded'],
      default: 'pending'
    },
    paymentMethod: String,
    paidAt: Date
  },
  couponApplied: {
    code: String,
    discount: Number,
    discountAmount: Number
  },
  bookingStatus: {
    type: String,
    enum: ['pending', 'confirmed', 'ongoing', 'completed', 'cancelled'],
    default: 'pending'
  },
  driverDetails: {
    name: String,
    licenseNumber: String,
    licenseExpiry: Date,
    phone: String
  },
  specialRequests: String,
  damageReport: {
    beforeRental: {
      images: [String],
      notes: String
    },
    afterRental: {
      images: [String],
      notes: String,
      damageFound: Boolean,
      repairCost: Number
    }
  },
  rating: {
    carRating: {
      type: Number,
      min: 1,
      max: 5
    },
    serviceRating: {
      type: Number,
      min: 1,
      max: 5
    },
    review: String,
    ratedAt: Date
  }
}, {
  timestamps: true
});

// Validate end date is after start date
bookingSchema.pre('save', function(next) {
  if (this.endDate <= this.startDate) {
    next(new Error('End date must be after start date'));
  }
  next();
});

// Index for efficient queries
bookingSchema.index({ user: 1, createdAt: -1 });
bookingSchema.index({ car: 1, startDate: 1, endDate: 1 });
bookingSchema.index({ bookingStatus: 1 });

module.exports = mongoose.model('Booking', bookingSchema);

// =============================================
// models/Coupon.js
// =============================================
const mongoose = require('mongoose');

const couponSchema = new mongoose.Schema({
  code: {
    type: String,
    required: [true, 'Please add coupon code'],
    unique: true,
    uppercase: true
  },
  description: {
    type: String,
    required: [true, 'Please add coupon description']
  },
  discountType: {
    type: String,
    enum: ['percentage', 'fixed'],
    required: [true, 'Please specify discount type']
  },
  discountValue: {
    type: Number,
    required: [true, 'Please add discount value']
  },
  minimumAmount: {
    type: Number,
    default: 0
  },
  maximumDiscount: {
    type: Number // For percentage type coupons
  },
  usageLimit: {
    type: Number,
    default: null // null means unlimited
  },
  usedCount: {
    type: Number,
    default: 0
  },
  userUsageLimit: {
    type: Number,
    default: 1 // How many times a single user can use this coupon
  },
  usedBy: [{
    user: {
      type: mongoose.Schema.ObjectId,
      ref: 'User'
    },
    usedCount: {
      type: Number,
      default: 1
    },
    lastUsed: {
      type: Date,
      default: Date.now
    }
  }],
  validFrom: {
    type: Date,
    required: [true, 'Please add valid from date']
  },
  validTill: {
    type: Date,
    required: [true, 'Please add valid till date']
  },
  applicableCars: [{
    type: mongoose.Schema.ObjectId,
    ref: 'Car'
  }], // Empty array means applicable to all cars
  isActive: {
    type: Boolean,
    default: true
  }
}, {
  timestamps: true
});

// Validate valid till date is after valid from date
couponSchema.pre('save', function(next) {
  if (this.validTill <= this.validFrom) {
    next(new Error('Valid till date must be after valid from date'));
  }
  next();
});

module.exports = mongoose.model('Coupon', couponSchema);

// =============================================
// middleware/authMiddleware.js
// =============================================
const jwt = require('jsonwebtoken');
const User = require('../models/User');
const logger = require('../utils/logger');

// Protect routes
const protect = async (req, res, next) => {
  let token;

  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
    try {
      // Get token from header
      token = req.headers.authorization.split(' ')[1];
      
      // Verify token
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      
      // Get user from the token
      req.user = await User.findById(decoded.id).select('-password');
      
      if (!req.user) {
        return res.status(401).json({ success: false, message: 'Not authorized, user not found' });
      }
      
      if (!req.user.isActive) {
        return res.status(401).json({ success: false, message: 'Account is deactivated' });
      }
      
      next();
    } catch (error) {
      logger.error(error);
      return res.status(401).json({ success: false, message: 'Not authorized, token failed' });
    }
  }

  if (!token) {
    return res.status(401).json({ success: false, message: 'Not authorized, no token' });
  }
};

// Grant access to specific roles
const authorize = (...roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        message: `User role ${req.user.role} is not authorized to access this route`
      });
    }
    next();
  };
};

module.exports = { protect, authorize };

// =============================================
// middleware/errorMiddleware.js
// =============================================
const logger = require('../utils/logger');

const errorHandler = (err, req, res, next) => {
  let error = { ...err };
  error.message = err.message;

  // Log error
  logger.error(err);

  // Mongoose bad ObjectId
  if (err.name === 'CastError') {
    const message = 'Resource not found';
    error = { message, statusCode: 404 };
  }

  // Mongoose duplicate key
  if (err.code === 11000) {
    const message = 'Duplicate field value entered';
    error = { message, statusCode: 400 };
  }

  // Mongoose validation error
  if (err.name === 'ValidationError') {
    const message = Object.values(err.errors).map(val => val.message);
    error = { message, statusCode: 400 };
  }

  res.status(error.statusCode || 500).json({
    success: false,
    message: error.message || 'Server Error'
  });
};

module.exports = errorHandler;

// =============================================
// middleware/uploadMiddleware.js
// =============================================
const multer = require('multer');
const path = require('path');

// Configure multer for memory storage
const storage = multer.memoryStorage();

const checkFileType = (file, cb) => {
  const filetypes = /jpeg|jpg|png|gif/;
  const extname = filetypes.test(path.extname(file.originalname).toLowerCase());
  const mimetype = filetypes.test(file.mimetype);

  if (mimetype && extname) {
    return cb(null, true);
  } else {
    cb(new Error('Please upload only images (jpeg, jpg, png, gif)'));
  }
};

const upload = multer({
  storage,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB limit
  fileFilter: function(req, file, cb) {
    checkFileType(file, cb);
  }
});

module.exports = { upload };

// =============================================
// utils/generateToken.js
// =============================================
const jwt = require('jsonwebtoken');

const generateToken = (id) => {
  return jwt.sign({ id }, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRE
  });
};

module.exports = generateToken;

// =============================================
// utils/validateInputs.js
// =============================================
const Joi = require('joi');

// User registration validation
const validateRegister = (data) => {
  const schema = Joi.object({
    name: Joi.string().min(2).max(50).required(),
    email: Joi.string().email().required(),
    password: Joi.string().min(6).required(),
    phone: Joi.string().pattern(/^[0-9]{10}$/).required()
  });
  
  return schema.validate(data);
};

// User login validation
const validateLogin = (data) => {
  const schema = Joi.object({
    email: Joi.string().email().required(),
    password: Joi.string().min(6).required()
  });
  
  return schema.validate(data);
};

// Car validation
const validateCar = (data) => {
  const schema = Joi.object({
    name: Joi.string().min(2).max(100).required(),
    brand: Joi.string().min(2).max(50).required(),
    model: Joi.string().min(2).max(50).required(),
    year: Joi.number().min(1980).max(new Date().getFullYear() + 1).required(),
    rentPerHour: Joi.number().min(1).required(),
    fuelType: Joi.string().valid('Petrol', 'Diesel', 'Electric', 'Hybrid').required(),
    transmission: Joi.string().valid('Manual', 'Automatic').required(),
    seatingCapacity: Joi.number().min(2).max(8).required(),
    mileage: Joi.number().min(1).required(),
    registrationNumber: Joi.string().required()
  });
  
  return schema.validate(data);
};

// Booking validation
const validateBooking = (data) => {
  const schema = Joi.object({
    car: Joi.string().required(),
    startDate: Joi.date().min('now').required(),
    endDate: Joi.date().greater(Joi.ref('startDate')).required()
  });
  
  return schema.validate(data);
};

module.exports = {
  validateRegister,
  validateLogin,
  validateCar,
  validateBooking
};

// =============================================
// utils/logger.js
// =============================================
const winston = require('winston');

const logger = winston.createLogger({
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'car-rental-api' },
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' })
  ]
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.simple()
    )
  }));
}

module.exports = logger;

// =============================================
// utils/pdfGenerator.js
// =============================================
const PDFDocument = require('pdfkit');
const fs = require('fs');
const path = require('path');

const generateInvoice = async (bookingData) => {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument();
      const filename = `invoice_${bookingData._id}.pdf`;
      const filepath = path.join(__dirname, '../uploads', filename);

      // Ensure uploads directory exists
      const uploadsDir = path.dirname(filepath);
      if (!fs.existsSync(uploadsDir)) {
        fs.mkdirSync(uploadsDir, { recursive: true });
      }

      doc.pipe(fs.createWriteStream(filepath));

      // Header
      doc.fontSize(20).text('CAR RENTAL INVOICE', 50, 50);
      doc.fontSize(10).text(`Invoice ID: ${bookingData._id}`, 50, 80);
      doc.text(`Date: ${new Date().toLocaleDateString()}`, 50, 95);

      // Customer Information
      doc.fontSize(14).text('Bill To:', 50, 130);
      doc.fontSize(10)
         .text(`Name: ${bookingData.user.name}`, 50, 150)
         .text(`Email: ${bookingData.user.email}`, 50, 165)
         .text(`Phone: ${bookingData.user.phone}`, 50, 180);

      // Car Information
      doc.fontSize(14).text('Car Details:', 50, 210);
      doc.fontSize(10)
         .text(`Car: ${bookingData.car.name}`, 50, 230)
         .text(`Model: ${bookingData.car.brand} ${bookingData.car.model}`, 50, 245)
         .text(`Registration: ${bookingData.car.registrationNumber}`, 50, 260);

      // Booking Details
      doc.fontSize(14).text('Booking Details:', 50, 290);
      doc.fontSize(10)
         .text(`Start Date: ${new Date(bookingData.startDate).toLocaleDateString()}`, 50, 310)
         .text(`End Date: ${new Date(bookingData.endDate).toLocaleDateString()}`, 50, 325)
         .text(`Total Hours: ${bookingData.totalHours}`, 50, 340)
         .text(`Rate per Hour: ₹${bookingData.car.rentPerHour}`, 50, 355);

      // Payment Details
      doc.fontSize(14).text('Payment Summary:', 50, 385);
      const subtotal = bookingData.totalHours * bookingData.car.rentPerHour;
      let y = 405;
      
      doc.fontSize(10).text(`Subtotal: ₹${subtotal}`, 50, y);
      y += 15;

      if (bookingData.couponApplied) {
        doc.text(`Discount (${bookingData.couponApplied.code}): -₹${bookingData.couponApplied.discountAmount}`, 50, y);
        y += 15;
      }

      doc.fontSize(12)
         .font('Helvetica-Bold')
         .text(`Total Amount: ₹${bookingData.totalAmount}`, 50, y);

      // Footer
      doc.fontSize(8)
         .font('Helvetica')
         .text('Thank you for choosing our car rental service!', 50, y + 40);

      doc.end();

      doc.on('end', () => {
        resolve(filepath);
      });

    } catch (error) {
      reject(error);
    }
  });
};

module.exports = { generateInvoice };

// =============================================
// controllers/authController.js
// =============================================
const User = require('../models/User');
const generateToken = require('../utils/generateToken');
const { validateRegister, validateLogin } = require('../utils/validateInputs');
const logger = require('../utils/logger');

// @desc    Register user
// @route   POST /api/auth/register
// @access  Public
const registerUser = async (req, res) => {
  try {
    const { error } = validateRegister(req.body);
    if (error) {
      return res.status(400).json({
        success: false,
        message: error.details[0].message
      });
    }

    const { name, email, password, phone } = req.body;

    // Check if user already exists
    const userExists = await User.findOne({ email });
    if (userExists) {
      return res.status(400).json({
        success: false,
        message: 'User already exists'
      });
    }

    // Create user
    const user = await User.create({
      name,
      email,
      password,
      phone
    });

    const token = generateToken(user._id);

    res.status(201).json({
      success: true,
      message: 'User registered successfully',
      token,
      user: {
        _id: user._id,
        name: user.name,
        email: user.email,
        role: user.role
      }
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// @desc    Login user
// @route   POST /api/auth/login
// @access  Public
const loginUser = async (req, res) => {
  try {
    const { error } = validateLogin(req.body);
    if (error) {
      return res.status(400).json({
        success: false,
        message: error.details[0].message
      });
    }

    const { email, password } = req.body;

    // Check for user
    const user = await User.findOne({ email }).select('+password');
    if (!user) {
      return res.status(401).json({
        success: false,
        message: 'Invalid credentials'
      });
    }

    // Check if password matches
    const isMatch = await user.matchPassword(password);
    if (!isMatch) {
      return res.status(401).json({
        success: false,
        message: 'Invalid credentials'
      });
    }

    // Update last login
    user.lastLogin = new Date();
    await user.save();

    const token = generateToken(user._id);

    res.json({
      success: true,
      data: booking
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// @desc    Cancel booking
// @route   PUT /api/bookings/:id/cancel
// @access  Private
const cancelBooking = async (req, res) => {
  try {
    const booking = await Booking.findById(req.params.id);

    if (!booking) {
      return res.status(404).json({
        success: false,
        message: 'Booking not found'
      });
    }

    // Check if user owns this booking
    if (booking.user.toString() !== req.user.id) {
      return res.status(403).json({
        success: false,
        message: 'Not authorized to cancel this booking'
      });
    }

    // Check if booking can be cancelled
    if (booking.bookingStatus === 'completed' || booking.bookingStatus === 'cancelled') {
      return res.status(400).json({
        success: false,
        message: 'Cannot cancel this booking'
      });
    }

    booking.bookingStatus = 'cancelled';
    await booking.save();

    res.json({
      success: true,
      message: 'Booking cancelled successfully',
      data: booking
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// @desc    Rate booking
// @route   PUT /api/bookings/:id/rate
// @access  Private
const rateBooking = async (req, res) => {
  try {
    const { carRating, serviceRating, review } = req.body;
    
    const booking = await Booking.findById(req.params.id);

    if (!booking) {
      return res.status(404).json({
        success: false,
        message: 'Booking not found'
      });
    }

    // Check if user owns this booking
    if (booking.user.toString() !== req.user.id) {
      return res.status(403).json({
        success: false,
        message: 'Not authorized to rate this booking'
      });
    }

    // Check if booking is completed
    if (booking.bookingStatus !== 'completed') {
      return res.status(400).json({
        success: false,
        message: 'Can only rate completed bookings'
      });
    }

    booking.rating = {
      carRating,
      serviceRating,
      review,
      ratedAt: new Date()
    };

    await booking.save();

    // Update car rating
    const car = await Car.findById(booking.car);
    if (car && carRating) {
      const totalRating = (car.rating.average * car.rating.count) + carRating;
      car.rating.count += 1;
      car.rating.average = totalRating / car.rating.count;
      await car.save();
    }

    res.json({
      success: true,
      message: 'Rating submitted successfully',
      data: booking
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

module.exports = {
  createBooking,
  handleStripeWebhook,
  getUserBookings,
  getBooking,
  cancelBooking,
  rateBooking
};

// =============================================
// controllers/adminController.js
// =============================================
const User = require('../models/User');
const Car = require('../models/Car');
const Booking = require('../models/Booking');
const Coupon = require('../models/Coupon');
const logger = require('../utils/logger');

// @desc    Get admin dashboard stats
// @route   GET /api/admin/dashboard
// @access  Private/Admin
const getDashboard = async (req, res) => {
  try {
    const totalUsers = await User.countDocuments({ role: 'user' });
    const totalCars = await Car.countDocuments();
    const totalBookings = await Booking.countDocuments();
    const totalRevenue = await Booking.aggregate([
      { $match: { 'paymentDetails.paymentStatus': 'completed' } },
      { $group: { _id: null, total: { $sum: '$totalAmount' } } }
    ]);

    const recentBookings = await Booking.find()
      .populate('user', 'name email')
      .populate('car', 'name brand model')
      .sort({ createdAt: -1 })
      .limit(10);

    const monthlyRevenue = await Booking.aggregate([
      {
        $match: {
          'paymentDetails.paymentStatus': 'completed',
          createdAt: { $gte: new Date(new Date().getFullYear(), 0, 1) }
        }
      },
      {
        $group: {
          _id: { month: { $month: '$createdAt' } },
          revenue: { $sum: '$totalAmount' },
          bookings: { $sum: 1 }
        }
      },
      { $sort: { '_id.month': 1 } }
    ]);

    res.json({
      success: true,
      data: {
        stats: {
          totalUsers,
          totalCars,
          totalBookings,
          totalRevenue: totalRevenue[0]?.total || 0
        },
        recentBookings,
        monthlyRevenue
      }
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// @desc    Get all users
// @route   GET /api/admin/users
// @access  Private/Admin
const getAllUsers = async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;

    let query = User.find({ role: 'user' });

    if (req.query.search) {
      query = query.find({
        $or: [
          { name: new RegExp(req.query.search, 'i') },
          { email: new RegExp(req.query.search, 'i') }
        ]
      });
    }

    const users = await query
      .select('-password')
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit);

    const total = await User.countDocuments(query.getFilter());

    res.json({
      success: true,
      data: users,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// @desc    Get all bookings
// @route   GET /api/admin/bookings
// @access  Private/Admin
const getAllBookings = async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;

    let query = Booking.find();

    if (req.query.status) {
      query = query.find({ bookingStatus: req.query.status });
    }

    if (req.query.search) {
      const users = await User.find({
        $or: [
          { name: new RegExp(req.query.search, 'i') },
          { email: new RegExp(req.query.search, 'i') }
        ]
      }).select('_id');
      
      const userIds = users.map(user => user._id);
      
      query = query.find({ user: { $in: userIds } });
    }

    const bookings = await query
      .populate('user', 'name email phone')
      .populate('car', 'name brand model registrationNumber')
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit);

    const total = await Booking.countDocuments(query.getFilter());

    res.json({
      success: true,
      data: bookings,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// @desc    Update booking status
// @route   PUT /api/admin/bookings/:id/status
// @access  Private/Admin
const updateBookingStatus = async (req, res) => {
  try {
    const { status } = req.body;
    
    const booking = await Booking.findById(req.params.id);
    
    if (!booking) {
      return res.status(404).json({
        success: false,
        message: 'Booking not found'
      });
    }

    booking.bookingStatus = status;
    await booking.save();

    res.json({
      success: true,
      message: 'Booking status updated successfully',
      data: booking
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// @desc    Toggle user active status
// @route   PUT /api/admin/users/:id/toggle-status
// @access  Private/Admin
const toggleUserStatus = async (req, res) => {
  try {
    const user = await User.findById(req.params.id);
    
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    user.isActive = !user.isActive;
    await user.save();

    res.json({
      success: true,
      message: `User ${user.isActive ? 'activated' : 'deactivated'} successfully`,
      data: user
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

module.exports = {
  getDashboard,
  getAllUsers,
  getAllBookings,
  updateBookingStatus,
  toggleUserStatus
};

// =============================================
// controllers/couponController.js
// =============================================
const Coupon = require('../models/Coupon');
const logger = require('../utils/logger');

// @desc    Get all coupons
// @route   GET /api/coupons
// @access  Private/Admin
const getCoupons = async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;

    const coupons = await Coupon.find()
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit);

    const total = await Coupon.countDocuments();

    res.json({
      success: true,
      data: coupons,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// @desc    Create coupon
// @route   POST /api/coupons
// @access  Private/Admin
const createCoupon = async (req, res) => {
  try {
    const coupon = await Coupon.create(req.body);

    res.status(201).json({
      success: true,
      message: 'Coupon created successfully',
      data: coupon
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// @desc    Update coupon
// @route   PUT /api/coupons/:id
// @access  Private/Admin
const updateCoupon = async (req, res) => {
  try {
    const coupon = await Coupon.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true, runValidators: true }
    );

    if (!coupon) {
      return res.status(404).json({
        success: false,
        message: 'Coupon not found'
      });
    }

    res.json({
      success: true,
      message: 'Coupon updated successfully',
      data: coupon
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// @desc    Delete coupon
// @route   DELETE /api/coupons/:id
// @access  Private/Admin
const deleteCoupon = async (req, res) => {
  try {
    const coupon = await Coupon.findById(req.params.id);

    if (!coupon) {
      return res.status(404).json({
        success: false,
        message: 'Coupon not found'
      });
    }

    await Coupon.findByIdAndDelete(req.params.id);

    res.json({
      success: true,
      message: 'Coupon deleted successfully'
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// @desc    Validate coupon
// @route   POST /api/coupons/validate
// @access  Private
const validateCoupon = async (req, res) => {
  try {
    const { code, totalAmount } = req.body;

    const coupon = await Coupon.findOne({
      code: code.toUpperCase(),
      isActive: true,
      validFrom: { $lte: new Date() },
      validTill: { $gte: new Date() }
    });

    if (!coupon) {
      return res.status(404).json({
        success: false,
        message: 'Invalid or expired coupon'
      });
    }

    // Check usage limits
    if (coupon.usageLimit && coupon.usedCount >= coupon.usageLimit) {
      return res.status(400).json({
        success: false,
        message: 'Coupon usage limit exceeded'
      });
    }

    // Check user usage limit
    const userUsage = coupon.usedBy.find(usage => usage.user.toString() === req.user.id);
    if (userUsage && userUsage.usedCount >= coupon.userUsageLimit) {
      return res.status(400).json({
        success: false,
        message: 'You have already used this coupon maximum times'
      });
    }

    // Check minimum amount
    if (totalAmount < coupon.minimumAmount) {
      return res.status(400).json({
        success: false,
        message: `Minimum order amount should be ₹${coupon.minimumAmount}`
      });
    }

    // Calculate discount
    let discountAmount = coupon.discountType === 'percentage' 
      ? Math.min((totalAmount * coupon.discountValue) / 100, coupon.maximumDiscount || totalAmount)
      : coupon.discountValue;

    const finalAmount = Math.max(totalAmount - discountAmount, 0);

    res.json({
      success: true,
      message: 'Coupon is valid',
      data: {
        coupon: {
          code: coupon.code,
          description: coupon.description,
          discountType: coupon.discountType,
          discountValue: coupon.discountValue
        },
        discountAmount,
        finalAmount
      }
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

module.exports = {
  getCoupons,
  createCoupon,
  updateCoupon,
  deleteCoupon,
  validateCoupon
};

// =============================================
// controllers/chatbotController.js
// =============================================
const { getAIResponse } = require('../services/aiService');
const Car = require('../models/Car');
const logger = require('../utils/logger');

// @desc    Handle chatbot queries
// @route   POST /api/chatbot/chat
// @access  Public
const handleChat = async (req, res) => {
  try {
    const { message, context } = req.body;

    if (!message) {
      return res.status(400).json({
        success: false,
        message: 'Message is required'
      });
    }

    // Check if query is about car search
    if (message.toLowerCase().includes('car') || message.toLowerCase().includes('rent')) {
      const cars = await Car.find({ isAvailable: true }).limit(3);
      
      const carSuggestions = cars.map(car => ({
        id: car._id,
        name: car.name,
        brand: car.brand,
        model: car.model,
        rentPerHour: car.rentPerHour,
        image: car.images[0]?.url
      }));

      const response = await getAIResponse(message, { cars: carSuggestions, context });

      return res.json({
        success: true,
        data: {
          message: response,
          suggestions: carSuggestions,
          type: 'car_search'
        }
      });
    }

    // General AI response
    const response = await getAIResponse(message, context);

    res.json({
      success: true,
      data: {
        message: response,
        type: 'general'
      }
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// @desc    Get FAQ
// @route   GET /api/chatbot/faq
// @access  Public
const getFAQ = async (req, res) => {
  try {
    const faq = [
      {
        question: 'How do I rent a car?',
        answer: 'You can browse our available cars, select your preferred vehicle, choose your rental dates, and proceed with the booking and payment process.'
      },
      {
        question: 'What documents do I need?',
        answer: 'You need a valid driving license, government-issued photo ID, and a credit/debit card for payment.'
      },
      {
        question: 'Can I cancel my booking?',
        answer: 'Yes, you can cancel your booking before the pickup time. Cancellation policies may apply based on how far in advance you cancel.'
      },
      {
        question: 'What if the car breaks down?',
        answer: 'We provide 24/7 roadside assistance. Contact our support team immediately if you experience any issues with the vehicle.'
      },
      {
        question: 'Is insurance included?',
        answer: 'Basic insurance is included with all rentals. Additional coverage options are available for purchase.'
      }
    ];

    res.json({
      success: true,
      data: faq
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

module.exports = {
  handleChat,
  getFAQ
};

// =============================================
// controllers/notificationController.js
// =============================================
const { sendEmail } = require('../services/emailService');
const { sendSMS } = require('../services/smsService');
const logger = require('../utils/logger');

// @desc    Send notification
// @route   POST /api/notifications/send
// @access  Private/Admin
const sendNotification = async (req, res) => {
  try {
    const { type, recipients, subject, message, template } = req.body;

    const results = [];

    for (const recipient of recipients) {
      try {
        if (type === 'email') {
          await sendEmail({
            to: recipient.email,
            subject,
            text: message,
            template,
            context: recipient
          });
          results.push({ recipient: recipient.email, status: 'sent' });
        } else if (type === 'sms') {
          await sendSMS(recipient.phone, message);
          results.push({ recipient: recipient.phone, status: 'sent' });
        }
      } catch (error) {
        logger.error(`Failed to send ${type} to ${recipient.email || recipient.phone}:`, error);
        results.push({ 
          recipient: recipient.email || recipient.phone, 
          status: 'failed', 
          error: error.message 
        });
      }
    }

    res.json({
      success: true,
      message: 'Notifications processed',
      data: results
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

module.exports = {
  sendNotification
};

// =============================================
// services/emailService.js
// =============================================
const nodemailer = require('nodemailer');
const logger = require('../utils/logger');

// Create transporter
const transporter = nodemailer.createTransporter({
  host: process.env.EMAIL_HOST,
  port: process.env.EMAIL_PORT,
  secure: false,
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASSWORD
  }
});

// Send email function
const sendEmail = async (options) => {
  try {
    const mailOptions = {
      from: `Car Rental <${process.env.EMAIL_FROM}>`,
      to: options.to,
      subject: options.subject,
      text: options.text,
      html: options.html
    };

    const info = await transporter.sendMail(mailOptions);
    logger.info(`Email sent: ${info.messageId}`);
    
    return info;
  } catch (error) {
    logger.error('Email sending failed:', error);
    throw error;
  }
};

// Send booking confirmation
const sendBookingConfirmation = async (booking) => {
  try {
    const subject = 'Booking Confirmation - Car Rental';
    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2>Booking Confirmed!</h2>
        <p>Dear ${booking.user.name},</p>
        <p>Your car rental booking has been confirmed. Here are the details:</p>
        
        <div style="background: #f5f5f5; padding: 20px; border-radius: 5px; margin: 20px 0;">
          <h3>Booking Details</h3>
          <p><strong>Booking ID:</strong> ${booking._id}</p>
          <p><strong>Car:</strong> ${booking.car.brand} ${booking.car.model}</p>
          <p><strong>Start Date:</strong> ${new Date(booking.startDate).toLocaleString()}</p>
          <p><strong>End Date:</strong> ${new Date(booking.endDate).toLocaleString()}</p>
          <p><strong>Total Hours:</strong> ${booking.totalHours}</p>
          <p><strong>Total Amount:</strong> ₹${booking.totalAmount}</p>
        </div>
        
        <p>Please keep this confirmation for your records.</p>
        <p>Thank you for choosing our car rental service!</p>
        
        <hr>
        <p style="color: #666; font-size: 12px;">
          This is an automated email. Please do not reply to this email.
        </p>
      </div>
    `;

    await sendEmail({
      to: booking.user.email,
      subject,
      html
    });

  } catch (error) {
    logger.error('Failed to send booking confirmation:', error);
    throw error;
  }
};

// Send booking reminder
const sendBookingReminder = async (booking) => {
  try {
    const subject = 'Booking Reminder - Car Rental';
    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2>Booking Reminder</h2>
        <p>Dear ${booking.user.name},</p>
        <p>This is a reminder that your car rental booking starts soon:</p>
        
        <div style="background: #f5f5f5; padding: 20px; border-radius: 5px; margin: 20px 0;">
          <p><strong>Car:</strong> ${booking.car.brand} ${booking.car.model}</p>
          <p><strong>Start Date:</strong> ${new Date(booking.startDate).toLocaleString()}</p>
          <p><strong>Pickup Location:</strong> ${booking.pickupLocation?.address || 'TBD'}</p>
        </div>
        
        <p>Please ensure you have all required documents and arrive on time.</p>
        
        <hr>
        <p style="color: #666; font-size: 12px;">
          This is an automated email. Please do not reply to this email.
        </p>
      </div>
    `;

    await sendEmail({
      to: booking.user.email,
      subject,
      html
    });

  } catch (error) {
    logger.error('Failed to send booking reminder:', error);
    throw error;
  }
};

module.exports = {
  sendEmail,
  sendBookingConfirmation,
  sendBookingReminder
};

// =============================================
// services/smsService.js
// =============================================
const twilio = require('twilio');
const logger = require('../utils/logger');

const client = twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN);

// Send SMS function
const sendSMS = async (to, message) => {
  try {
    const result = await client.messages.create({
      body: message,
      from: process.env.TWILIO_PHONE_NUMBER,
      to: to
    });

    logger.info(`SMS sent: ${result.sid}`);
    return result;

  } catch (error) {
    logger.error('SMS sending failed:', error);
    throw error;
  }
};

// Send booking confirmation SMS
const sendBookingConfirmationSMS = async (booking) => {
  try {
    const message = `Booking Confirmed! Your ${booking.car.brand} ${booking.car.model} is reserved from ${new Date(booking.startDate).toLocaleDateString()} to ${new Date(booking.endDate).toLocaleDateString()}. Booking ID: ${booking._id}`;
    
    await sendSMS(booking.user.phone, message);

  } catch (error) {
    logger.error('Failed to send booking confirmation SMS:', error);
    throw error;
  }
};

module.exports = {
  sendSMS,
  sendBookingConfirmationSMS
};

// =============================================
// services/aiService.js
// =============================================
const OpenAI = require('openai');
const logger = require('../utils/logger');

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

// Get AI response
const getAIResponse = async (message, context = {}) => {
  try {
    const systemPrompt = `You are a helpful car rental assistant. You can help users with:
    - Finding the right car for their needs
    - Explaining rental process and policies
    - Answering questions about booking and payments
    - Providing general information about car rental services
    
    Be friendly, helpful, and professional. Keep responses concise but informative.
    
    Context: ${JSON.stringify(context)}`;

    const completion = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: message }
      ],
      max_tokens: 150,
      temperature: 0.7
    });

    return completion.choices[0].message.content;

  } catch (error) {
    logger.error('AI service error:', error);
    
    // Fallback responses for common queries
    const fallbackResponses = {
      'car': 'I can help you find the perfect car for your needs. What type of vehicle are you looking for?',
      'rent': 'Our rental process is simple: browse cars, select dates, book online, and enjoy your ride!',
      'price': 'Our rental rates vary by car type and duration. You can see the hourly rates on each car listing.',
      'booking': 'To book a car, select your preferred vehicle, choose pickup/dropoff dates, and complete the payment process.',
      'default': 'I\'m here to help you with car rentals. Feel free to ask about our vehicles, pricing, or booking process!'
    };

    const lowerMessage = message.toLowerCase();
    for (const [key, response] of Object.entries(fallbackResponses)) {
      if (lowerMessage.includes(key)) {
        return response;
      }
    }

    return fallbackResponses.default;
  }
};

module.exports = {
  getAIResponse
};

// =============================================
// services/pricingService.js
// =============================================
const Car = require('../models/Car');
const logger = require('../utils/logger');

// Calculate dynamic pricing
const calculatePrice = async (carId, hours, startDate) => {
  try {
    const car = await Car.findById(carId);
    if (!car) {
      throw new Error('Car not found');
    }

    let basePrice = car.rentPerHour * hours;
    let multiplier = 1;

    // Weekend pricing (Friday, Saturday, Sunday)
    const dayOfWeek = new Date(startDate).getDay();
    if ([0, 5, 6].includes(dayOfWeek)) {
      multiplier += 0.2; // 20% increase on weekends
    }

    // Holiday pricing (simplified - you can enhance this)
    const holidays = [
      '2024-01-01', '2024-08-15', '2024-10-02', '2024-12-25'
    ];
    const dateString = new Date(startDate).toISOString().split('T')[0];
    if (holidays.includes(dateString)) {
      multiplier += 0.3; // 30% increase on holidays
    }

    // Long term discount
    if (hours >= 168) { // 7 days or more
      multiplier -= 0.15; // 15% discount for weekly rentals
    } else if (hours >= 72) { // 3 days or more
      multiplier -= 0.1; // 10% discount for 3+ days
    }

    // Demand-based pricing (simplified)
    const currentBookings = await require('../models/Booking').countDocuments({
      startDate: { $lte: new Date(startDate) },
      endDate: { $gte: new Date(startDate) },
      bookingStatus: { $in: ['confirmed', 'ongoing'] }
    });

    if (currentBookings > 10) {
      multiplier += 0.15; // 15% increase during high demand
    }

    const finalPrice = Math.round(basePrice * multiplier);
    
    logger.info(`Price calculated for car ${carId}: Base: ${basePrice}, Multiplier: ${multiplier}, Final: ${finalPrice}`);
    
    return finalPrice;

  } catch (error) {
    logger.error('Pricing calculation error:', error);
    // Return base price as fallback
    const car = await Car.findById(carId);
    return car ? car.rentPerHour * hours : 0;
  }
};

// Get price breakdown
const getPriceBreakdown = async (carId, hours, startDate, couponCode = null) => {
  try {
    const car = await Car.findById(carId);
    if (!car) {
      throw new Error('Car not found');
    }

    const basePrice = car.rentPerHour * hours;
    const finalPrice = await calculatePrice(carId, hours, startDate);
    const adjustments = finalPrice - basePrice;

    let discount = 0;
    if (couponCode) {
      const Coupon = require('../models/Coupon');
      const coupon = await Coupon.findOne({
        code: couponCode.toUpperCase(),
        isActive: true,
        validFrom: { $lte: new Date() },
        validTill: { $gte: new Date() }
      });

      if (coupon && finalPrice >= coupon.minimumAmount) {
        discount = coupon.discountType === 'percentage' 
          ? Math.min((finalPrice * coupon.discountValue) / 100, coupon.maximumDiscount || finalPrice)
          : coupon.discountValue;
      }
    }

    return {
      basePrice,
      adjustments,
      discount,
      finalPrice: finalPrice - discount,
      breakdown: {
        hourlyRate: car.rentPerHour,
        hours,
        subtotal: basePrice,
        priceAdjustments: adjustments,
        couponDiscount: -discount,
        total: finalPrice - discount
      }
    };

  } catch (error) {
    logger.error('Price breakdown error:', error);
    throw error;
  }
};

module.exports = {
  calculatePrice,
  getPriceBreakdown
};

// =============================================
// routes/authRoutes.js
// =============================================
const express = require('express');
const {
  registerUser,
  loginUser,
  getUserProfile,
  updateUserProfile
} = require('../controllers/authController');
const { protect } = require('../middleware/authMiddleware');

const router = express.Router();

router.post('/register', registerUser);
router.post('/login', loginUser);
router.route('/profile').get(protect, getUserProfile).put(protect, updateUserProfile);

module.exports = router;

// =============================================
// routes/carRoutes.js
// =============================================
const express = require('express');
const {
  getCars,
  getCar,
  createCar,
  updateCar,
  deleteCar
} = require('../controllers/carController');
const { protect, authorize } = require('../middleware/authMiddleware');
const { upload } = require('../middleware/uploadMiddleware');

const router = express.Router();

router.route('/')
  .get(getCars)
  .post(protect, authorize('admin'), upload.array('images', 5), createCar);

router.route('/:id')
  .get(getCar)
  .put(protect, authorize('admin'), upload.array('images', 5), updateCar)
  .delete(protect, authorize('admin'), deleteCar);

module.exports = router;

// =============================================
// routes/bookingRoutes.js
// =============================================
const express = require('express');
const {
  createBooking,
  handleStripeWebhook,
  getUserBookings,
  getBooking,
  cancelBooking,
  rateBooking
} = require('../controllers/bookingController');
const { protect } = require('../middleware/authMiddleware');

const router = express.Router();

router.post('/webhook', express.raw({type: 'application/json'}), handleStripeWebhook);

router.route('/')
  .get(protect, getUserBookings)
  .post(protect, createBooking);

router.route('/:id')
  .get(protect, getBooking);

router.put('/:id/cancel', protect, cancelBooking);
router.put('/:id/rate', protect, rateBooking);

module.exports = router;

// =============================================
// routes/adminRoutes.js
// =============================================
const express = require('express');
const {
  getDashboard,
  getAllUsers,
  getAllBookings,
  updateBookingStatus,
  toggleUserStatus
} = require('../controllers/adminController');
const { protect, authorize } = require('../middleware/authMiddleware');

const router = express.Router();

// All routes are admin protected
router.use(protect);
router.use(authorize('admin'));

router.get('/dashboard', getDashboard);
router.get('/users', getAllUsers);
router.get('/bookings', getAllBookings);
router.put('/bookings/:id/status', updateBookingStatus);
router.put('/users/:id/toggle-status', toggleUserStatus);

module.exports = router;

// =============================================
// routes/couponRoutes.js
// =============================================
const express = require('express');
const {
  getCoupons,
  createCoupon,
  updateCoupon,
  deleteCoupon,
  validateCoupon
} = require('../controllers/couponController');
const { protect, authorize } = require('../middleware/authMiddleware');

const router = express.Router();

router.post('/validate', protect, validateCoupon);

router.route('/')
  .get(protect, authorize('admin'), getCoupons)
  .post(protect, authorize('admin'), createCoupon);

router.route('/:id')
  .put(protect, authorize('admin'), updateCoupon)
  .delete(protect, authorize('admin'), deleteCoupon);

module.exports = router;

// =============================================
// routes/chatbotRoutes.js
// =============================================
const express = require('express');
const {
  handleChat,
  getFAQ
} = require('../controllers/chatbotController');

const router = express.Router();

router.post('/chat', handleChat);
router.get('/faq', getFAQ);

module.exports = router;

// =============================================
// Additional Setup Instructions
// =============================================

/*
SETUP INSTRUCTIONS:

1. Install Dependencies:
   npm install

2. Environment Setup:
   - Copy .env.example to .env
   - Fill in all required environment variables
   - Ensure MongoDB is running locally or update MONGODB_URI

3. Database Setup:
   - MongoDB will create collections automatically
   - Consider adding indexes for better performance:
     db.cars.createIndex({ name: "text", brand: "text", model: "text" })
     db.cars.createIndex({ "location.city": 1 })

4. Create Admin User (run in MongoDB shell or create a script):
   db.users.insertOne({
     name: "Admin",
     email: "admin@carrental.com",
     password: "$2a$10$...", // Hash this password
     role: "admin",
     phone: "1234567890",
     isActive: true,
     createdAt: new Date(),
     updatedAt: new Date()
   })

5. Stripe Setup:
   - Create Stripe account and get API keys
   - Set up webhook endpoint for payment confirmation
   - Add webhook URL in Stripe dashboard: /api/bookings/webhook

6. Cloudinary Setup:
   - Create Cloudinary account
   - Get cloud name, API key, and API secret
   - Create folders: car-rental/cars, car-rental/damage-reports

7. Email Setup:
   - For Gmail: Enable 2FA and create app-specific password
   - For SendGrid: Get API key and verify sender identity

8. Twilio Setup (for SMS):
   - Create Twilio account
   - Get Account SID, Auth Token, and phone number

9. OpenAI Setup (for Chatbot):
   - Create OpenAI account and get API key

10. Create Logs Directory:
    mkdir logs

11. Start Development Server:
    npm run dev

12. API Testing:
    - Use tools like Postman or Thunder Client
    - Import the API collection (create one based on routes)

API ENDPOINTS SUMMARY:

Authentication:
- POST /api/auth/register - Register new user
- POST /api/auth/login - User login  
- GET /api/auth/profile - Get user profile
- PUT /api/auth/profile - Update user profile

Cars:
- GET /api/cars - Get all cars (with filters)
- GET /api/cars/:id - Get single car
- POST /api/cars - Create car (Admin only)
- PUT /api/cars/:id - Update car (Admin only)
- DELETE /api/cars/:id - Delete car (Admin only)

Bookings:
- GET /api/bookings - Get user bookings
- POST /api/bookings - Create booking
- GET /api/bookings/:id - Get single booking
- PUT /api/bookings/:id/cancel - Cancel booking
- PUT /api/bookings/:id/rate - Rate completed booking
- POST /api/bookings/webhook - Stripe webhook

Admin:
- GET /api/admin/dashboard - Dashboard stats
- GET /api/admin/users - Get all users
- GET /api/admin/bookings - Get all bookings
- PUT /api/admin/bookings/:id/status - Update booking status
- PUT /api/admin/users/:id/toggle-status - Toggle user status

Coupons:
- GET /api/coupons - Get all coupons (Admin only)
- POST /api/coupons - Create coupon (Admin only)
- PUT /api/coupons/:id - Update coupon (Admin only)
- DELETE /api/coupons/:id - Delete coupon (Admin only)
- POST /api/coupons/validate - Validate coupon

Chatbot:
- POST /api/chatbot/chat - Chat with AI
- GET /api/chatbot/faq - Get FAQ

SECURITY FEATURES:
- JWT authentication
- Password hashing with bcrypt
- Rate limiting
- Helmet for security headers
- CORS protection
- Input validation with Joi
- File upload restrictions
- Role-based access control

ADDITIONAL FEATURES TO IMPLEMENT:
- Email templates with better styling
- SMS notifications for booking updates
- Real-time notifications with Socket.io
- Advanced search with Elasticsearch
- Caching with Redis
- Image optimization
- Backup and restore functionality
- Analytics and reporting
- Mobile app API optimization
- Payment gateway integration (Razorpay, PayPal)
- Multi-language support
- Geolocation services
- Push notifications
- Social login integration

DEPLOYMENT CHECKLIST:
- Set NODE_ENV=production
- Use production database
- Configure production CORS origins
- Set up SSL certificates
- Configure PM2 for process management
- Set up monitoring (New Relic, DataDog)
- Configure log rotation
- Set up automated backups
- Configure CDN for static assets
- Set up error tracking (Sentry)
- Load testing
- Security testing
*/,
      message: 'Login successful',
      token,
      user: {
        _id: user._id,
        name: user.name,
        email: user.email,
        role: user.role
      }
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// @desc    Get user profile
// @route   GET /api/auth/profile
// @access  Private
const getUserProfile = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);
    res.json({
      success: true,
      user
    });
  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// @desc    Update user profile
// @route   PUT /api/auth/profile
// @access  Private
const updateUserProfile = async (req, res) => {
  try {
    const user = await User.findById(req.user.id);

    if (user) {
      user.name = req.body.name || user.name;
      user.phone = req.body.phone || user.phone;
      user.address = req.body.address || user.address;

      if (req.body.password) {
        user.password = req.body.password;
      }

      const updatedUser = await user.save();

      res.json({
        success: true,
        message: 'Profile updated successfully',
        user: {
          _id: updatedUser._id,
          name: updatedUser.name,
          email: updatedUser.email,
          phone: updatedUser.phone,
          role: updatedUser.role,
          address: updatedUser.address
        }
      });
    } else {
      res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }
  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

module.exports = {
  registerUser,
  loginUser,
  getUserProfile,
  updateUserProfile
};

// =============================================
// controllers/carController.js
// =============================================
const Car = require('../models/Car');
const { validateCar } = require('../utils/validateInputs');
const cloudinary = require('../config/cloudinary');
const logger = require('../utils/logger');

// @desc    Get all cars
// @route   GET /api/cars
// @access  Public
const getCars = async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;

    // Build query
    let query = Car.find({ isAvailable: true });

    // Search
    if (req.query.search) {
      query = query.find({
        $text: { $search: req.query.search }
      });
    }

    // Filter by fuel type
    if (req.query.fuelType) {
      query = query.find({ fuelType: req.query.fuelType });
    }

    // Filter by transmission
    if (req.query.transmission) {
      query = query.find({ transmission: req.query.transmission });
    }

    // Filter by seating capacity
    if (req.query.seatingCapacity) {
      query = query.find({ seatingCapacity: req.query.seatingCapacity });
    }

    // Filter by location
    if (req.query.city) {
      query = query.find({ 'location.city': new RegExp(req.query.city, 'i') });
    }

    // Filter by price range
    if (req.query.minPrice || req.query.maxPrice) {
      const priceFilter = {};
      if (req.query.minPrice) priceFilter.$gte = parseInt(req.query.minPrice);
      if (req.query.maxPrice) priceFilter.$lte = parseInt(req.query.maxPrice);
      query = query.find({ rentPerHour: priceFilter });
    }

    // Sort
    if (req.query.sortBy) {
      const sortOrder = req.query.order === 'desc' ? -1 : 1;
      query = query.sort({ [req.query.sortBy]: sortOrder });
    } else {
      query = query.sort({ createdAt: -1 });
    }

    // Execute query
    const cars = await query.skip(skip).limit(limit);
    const total = await Car.countDocuments(query.getFilter());

    res.json({
      success: true,
      data: cars,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// @desc    Get single car
// @route   GET /api/cars/:id
// @access  Public
const getCar = async (req, res) => {
  try {
    const car = await Car.findById(req.params.id);

    if (!car) {
      return res.status(404).json({
        success: false,
        message: 'Car not found'
      });
    }

    res.json({
      success: true,
      data: car
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// @desc    Create new car
// @route   POST /api/cars
// @access  Private/Admin
const createCar = async (req, res) => {
  try {
    const { error } = validateCar(req.body);
    if (error) {
      return res.status(400).json({
        success: false,
        message: error.details[0].message
      });
    }

    let images = [];
    
    // Handle image uploads
    if (req.files && req.files.length > 0) {
      for (const file of req.files) {
        const result = await cloudinary.uploader.upload_stream(
          { folder: 'car-rental/cars' },
          (error, result) => {
            if (error) throw error;
            return result;
          }
        );
        
        images.push({
          url: result.secure_url,
          public_id: result.public_id
        });
      }
    }

    const car = await Car.create({
      ...req.body,
      images
    });

    res.status(201).json({
      success: true,
      message: 'Car created successfully',
      data: car
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// @desc    Update car
// @route   PUT /api/cars/:id
// @access  Private/Admin
const updateCar = async (req, res) => {
  try {
    let car = await Car.findById(req.params.id);

    if (!car) {
      return res.status(404).json({
        success: false,
        message: 'Car not found'
      });
    }

    // Handle new image uploads
    if (req.files && req.files.length > 0) {
      // Delete old images from cloudinary
      if (car.images && car.images.length > 0) {
        for (const image of car.images) {
          await cloudinary.uploader.destroy(image.public_id);
        }
      }

      // Upload new images
      const images = [];
      for (const file of req.files) {
        const result = await cloudinary.uploader.upload_stream(
          { folder: 'car-rental/cars' },
          (error, result) => {
            if (error) throw error;
            return result;
          }
        );
        
        images.push({
          url: result.secure_url,
          public_id: result.public_id
        });
      }
      
      req.body.images = images;
    }

    car = await Car.findByIdAndUpdate(req.params.id, req.body, {
      new: true,
      runValidators: true
    });

    res.json({
      success: true,
      message: 'Car updated successfully',
      data: car
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// @desc    Delete car
// @route   DELETE /api/cars/:id
// @access  Private/Admin
const deleteCar = async (req, res) => {
  try {
    const car = await Car.findById(req.params.id);

    if (!car) {
      return res.status(404).json({
        success: false,
        message: 'Car not found'
      });
    }

    // Delete images from cloudinary
    if (car.images && car.images.length > 0) {
      for (const image of car.images) {
        await cloudinary.uploader.destroy(image.public_id);
      }
    }

    await Car.findByIdAndDelete(req.params.id);

    res.json({
      success: true,
      message: 'Car deleted successfully'
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

module.exports = {
  getCars,
  getCar,
  createCar,
  updateCar,
  deleteCar
};

// =============================================
// controllers/bookingController.js
// =============================================
const Booking = require('../models/Booking');
const Car = require('../models/Car');
const Coupon = require('../models/Coupon');
const { validateBooking } = require('../utils/validateInputs');
const stripe = require('../config/stripe');
const { generateInvoice } = require('../utils/pdfGenerator');
const { sendBookingConfirmation } = require('../services/emailService');
const pricingService = require('../services/pricingService');
const logger = require('../utils/logger');

// @desc    Create booking
// @route   POST /api/bookings
// @access  Private
const createBooking = async (req, res) => {
  try {
    const { error } = validateBooking(req.body);
    if (error) {
      return res.status(400).json({
        success: false,
        message: error.details[0].message
      });
    }

    const { car: carId, startDate, endDate, couponCode } = req.body;

    // Check if car exists and is available
    const car = await Car.findById(carId);
    if (!car || !car.isAvailable) {
      return res.status(404).json({
        success: false,
        message: 'Car not found or not available'
      });
    }

    // Check for conflicting bookings
    const conflictingBookings = await Booking.find({
      car: carId,
      $or: [
        {
          startDate: { $lte: new Date(endDate) },
          endDate: { $gte: new Date(startDate) }
        }
      ],
      bookingStatus: { $in: ['confirmed', 'ongoing'] }
    });

    if (conflictingBookings.length > 0) {
      return res.status(400).json({
        success: false,
        message: 'Car is not available for selected dates'
      });
    }

    // Calculate total hours and amount
    const start = new Date(startDate);
    const end = new Date(endDate);
    const totalHours = Math.ceil((end - start) / (1000 * 60 * 60));
    
    let totalAmount = await pricingService.calculatePrice(carId, totalHours, start);
    let couponApplied = null;

    // Apply coupon if provided
    if (couponCode) {
      const coupon = await Coupon.findOne({ 
        code: couponCode.toUpperCase(),
        isActive: true,
        validFrom: { $lte: new Date() },
        validTill: { $gte: new Date() }
      });

      if (coupon) {
        const discountAmount = coupon.discountType === 'percentage' 
          ? Math.min((totalAmount * coupon.discountValue) / 100, coupon.maximumDiscount || totalAmount)
          : coupon.discountValue;

        if (totalAmount >= coupon.minimumAmount) {
          totalAmount -= discountAmount;
          couponApplied = {
            code: coupon.code,
            discount: coupon.discountValue,
            discountAmount
          };
        }
      }
    }

    // Create Stripe checkout session
    const session = await stripe.checkout.sessions.create({
      payment_method_types: ['card'],
      line_items: [{
        price_data: {
          currency: 'inr',
          product_data: {
            name: `${car.brand} ${car.model}`,
            description: `Car rental for ${totalHours} hours`,
          },
          unit_amount: totalAmount * 100, // Stripe expects amount in smallest currency unit
        },
        quantity: 1,
      }],
      mode: 'payment',
      success_url: `${process.env.CLIENT_URL}/booking-success?session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${process.env.CLIENT_URL}/booking-cancel`,
      metadata: {
        carId,
        userId: req.user.id,
        startDate,
        endDate,
        totalHours: totalHours.toString(),
        couponCode: couponCode || ''
      }
    });

    // Create booking with pending status
    const booking = await Booking.create({
      user: req.user.id,
      car: carId,
      startDate,
      endDate,
      totalHours,
      totalAmount,
      paymentDetails: {
        stripeSessionId: session.id,
        paymentStatus: 'pending'
      },
      couponApplied,
      ...req.body
    });

    res.status(201).json({
      success: true,
      message: 'Booking created successfully',
      data: booking,
      checkoutUrl: session.url
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// @desc    Handle Stripe webhook
// @route   POST /api/bookings/webhook
// @access  Public
const handleStripeWebhook = async (req, res) => {
  try {
    const sig = req.headers['stripe-signature'];
    const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET;

    let event;
    try {
      event = stripe.webhooks.constructEvent(req.body, sig, endpointSecret);
    } catch (err) {
      logger.error(`Webhook signature verification failed: ${err.message}`);
      return res.status(400).send(`Webhook Error: ${err.message}`);
    }

    if (event.type === 'checkout.session.completed') {
      const session = event.data.object;
      
      // Update booking status
      const booking = await Booking.findOne({ 
        'paymentDetails.stripeSessionId': session.id 
      }).populate('user car');

      if (booking) {
        booking.paymentDetails.paymentStatus = 'completed';
        booking.paymentDetails.paidAt = new Date();
        booking.bookingStatus = 'confirmed';
        await booking.save();

        // Send confirmation email
        await sendBookingConfirmation(booking);

        // Generate and save invoice
        const invoicePath = await generateInvoice(booking);
        logger.info(`Invoice generated: ${invoicePath}`);
      }
    }

    res.status(200).json({ received: true });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// @desc    Get user bookings
// @route   GET /api/bookings
// @access  Private
const getUserBookings = async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;

    const bookings = await Booking.find({ user: req.user.id })
      .populate('car', 'name brand model images registrationNumber')
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit);

    const total = await Booking.countDocuments({ user: req.user.id });

    res.json({
      success: true,
      data: bookings,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit)
      }
    });

  } catch (error) {
    logger.error(error);
    res.status(500).json({
      success: false,
      message: 'Server error'
    });
  }
};

// @desc    Get single booking
// @route   GET /api/bookings/:id
// @access  Private
const getBooking = async (req, res) => {
  try {
    const booking = await Booking.findById(req.params.id)
      .populate('user', 'name email phone')
      .populate('car');

    if (!booking) {
      return res.status(404).json({
        success: false,
        message: 'Booking not found'
      });
    }

    // Check if user owns this booking or is admin
    if (booking.user._id.toString() !== req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'Not authorized to access this booking'
      });
    }

    res.json({
      success: true